{"version":3,"sources":["src/server/bridges/CommandBridge.ts"],"names":[],"mappings":";;;AACA,2EAAwE;AACxE,2EAAwE;AACxE,kEAA+D;AAC/D,6CAA0C;AAE1C,MAAsB,aAAc,SAAQ,uBAAU;IAC3C,kBAAkB,CAAC,OAAe,EAAE,KAAa;QACpD,IAAI,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,EAAE;YAClC,OAAO,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;SAChD;IACL,CAAC;IAEM,eAAe,CAAC,OAAe,EAAE,KAAa;QACjD,IAAI,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,EAAE;YAClC,OAAO,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;SAC7C;IACL,CAAC;IAEM,gBAAgB,CAAC,OAAe,EAAE,KAAa;QAClD,IAAI,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,EAAE;YAClC,OAAO,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;SAC9C;IACL,CAAC;IAEM,eAAe,CAAC,OAAsB,EAAE,KAAa;QACxD,IAAI,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,EAAE;YAClC,OAAO,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;SAC7C;IACL,CAAC;IAEM,iBAAiB,CAAC,OAAsB,EAAE,KAAa;QAC1D,IAAI,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,EAAE;YAClC,OAAO,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;SAC/C;IACL,CAAC;IAEM,mBAAmB,CAAC,OAAe,EAAE,KAAa;QACrD,IAAI,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,EAAE;YAClC,OAAO,IAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;SACjD;IACL,CAAC;IA6DO,oBAAoB,CAAC,KAAa;QACtC,IAAI,2CAAoB,CAAC,aAAa,CAAC,KAAK,EAAE,+BAAc,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;YAC3E,OAAO,IAAI,CAAC;SACf;QAED,2CAAoB,CAAC,gBAAgB,CAAC,IAAI,6CAAqB,CAAC;YAC5D,KAAK;YACL,kBAAkB,EAAE,CAAC,+BAAc,CAAC,OAAO,CAAC,OAAO,CAAC;SACvD,CAAC,CAAC,CAAC;QAEJ,OAAO,KAAK,CAAC;IACjB,CAAC;CACJ;AA5GD,sCA4GC","file":"CommandBridge.js","sourcesContent":["import { ISlashCommand } from '../../definition/slashcommands';\nimport { PermissionDeniedError } from '../errors/PermissionDeniedError';\nimport { AppPermissionManager } from '../managers/AppPermissionManager';\nimport { AppPermissions } from '../permissions/AppPermissions';\nimport { BaseBridge } from './BaseBridge';\n\nexport abstract class CommandBridge extends BaseBridge {\n    public doDoesCommandExist(command: string, appId: string): boolean {\n        if (this.hasDefaultPermission(appId)) {\n            return this.doesCommandExist(command, appId);\n        }\n    }\n\n    public doEnableCommand(command: string, appId: string): void {\n        if (this.hasDefaultPermission(appId)) {\n            return this.enableCommand(command, appId);\n        }\n    }\n\n    public doDisableCommand(command: string, appId: string): void {\n        if (this.hasDefaultPermission(appId)) {\n            return this.disableCommand(command, appId);\n        }\n    }\n\n    public doModifyCommand(command: ISlashCommand, appId: string): void {\n        if (this.hasDefaultPermission(appId)) {\n            return this.modifyCommand(command, appId);\n        }\n    }\n\n    public doRegisterCommand(command: ISlashCommand, appId: string): void {\n        if (this.hasDefaultPermission(appId)) {\n            return this.registerCommand(command, appId);\n        }\n    }\n\n    public doUnregisterCommand(command: string, appId: string): void {\n        if (this.hasDefaultPermission(appId)) {\n            return this.unregisterCommand(command, appId);\n        }\n    }\n\n    /**\n     * Checks if the provided command already exists inside of the\n     * system which is being bridged. This does not check if the app\n     * registered it but it will return whether the supplied command is\n     * already defined by something else or not.\n     *\n     * @param command the command to check if it exists\n     * @param appId the id of the app calling this\n     * @returns whether the command is already in the system\n     */\n    protected abstract doesCommandExist(command: string, appId: string): boolean;\n\n    /**\n     * Enables an existing command from the bridged system. The callee\n     * must ensure that the command that's being enabled is defined by\n     * the bridged system and not another App since the bridged system\n     * will not check that.\n     *\n     * @param command the command to enable\n     * @param appId the id of the app calling this\n     */\n    protected abstract enableCommand(command: string, appId: string): void;\n\n    /**\n     * Disables an existing command from the bridged system, the callee must\n     * ensure the command disabling is defined by the system and not another\n     * App since the bridged system won't check that.\n     *\n     * @param command the command which to disable\n     * @param appId the id of the app calling this\n     */\n    protected abstract disableCommand(command: string, appId: string): void;\n\n    /**\n     * Changes how a system slash command behaves, allows Apps to provide\n     * different executors per system commands.\n     *\n     * @param command the modified slash command\n     * @param appId the id of the app calling this\n     */\n    protected abstract modifyCommand(command: ISlashCommand, appId: string): void;\n\n    /**\n     * Registers a command with the system which is being bridged.\n     *\n     * @param command the command to register\n     * @param appId the id of the app calling this\n     * @param toRun the executor which is called when the command is ran\n     */\n    protected abstract registerCommand(command: ISlashCommand, appId: string): void;\n\n    /**\n     * Unregisters the provided command from the bridged system.\n     *\n     * @param command the command to unregister\n     * @param appId the id of the app calling this\n     */\n    protected abstract unregisterCommand(command: string, appId: string): void;\n\n    private hasDefaultPermission(appId: string): boolean {\n        if (AppPermissionManager.hasPermission(appId, AppPermissions.command.default)) {\n            return true;\n        }\n\n        AppPermissionManager.notifyAboutError(new PermissionDeniedError({\n            appId,\n            missingPermissions: [AppPermissions.command.default],\n        }));\n\n        return false;\n    }\n}\n"]}